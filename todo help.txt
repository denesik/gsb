// Функции мира: 
// 1. Отложенно загрузить сектор. 
//      Нужно создать данный сектор и всех его соседей на карте.
//      Если сектор не был создан создаем его и кешируем.
//      Увеличиваем счетчик ссылок на сектор.
//      Если сектор еще не был добавлен на загрузку, отправляем его в загрузчик и увеличиваем счетчик ссылок, что бы сектор не выгрузился пока он находится в загрузчике.
// Загрузка сектора:
//      Выполняем процесс загрузки сектора.
//      Если загрузка завершена указываем что сектор загружен, вызываем событие загрузки сектора, уменьшаем счетчик ссылок.
// 2. Отложенно выгрузить сектор. 
//      Уменьшаем счетчик ссылок у сектора и всех его соседей.
//      Если счетчик ссылок ноль вызываем событие выгрузки, кешируем сектор и удаляем сектор.
// 3. Событие сектор загружен. Данный сектор и все его соседи загружены в память.
// 4. Событие сектор выгружен. Данный сектор выгружен из памяти.

и скорее всего в пункте Отложенно выгрузить сектор нужно будет сделать такую штуку:
Увеличить счетчик ссылок и поставить таймер на удаление.
По истечению таймера уменьшить счетчик ссылок

типа кеширование секторов после выгрузки на какое то время

пока не забыл, поправка к пред. мыслям
скорей всего кешировать сектора нужно перед вызовом события загрузки и после события выгрузки сектора.

тогда в кеше будет список секторов optional<Sector &> и если сектор есть, значит он загружен

Событие загрузки сектора нужно вызывать после того как сектор загрузился и только в том случае, если все его соседи уже были загружены.

Нужно сделать так, что бы события вызывались после итерации обновления, а не во время итерации (напр. при вызове функций отложенной загрузки / выгрузки сектора)

//--------------------

вобщем придумалось так

кольцевой буфер, элементами которого является структурка
struct
{
  optional<Sector &> sector;
  Mesh mesh;
}

Каждый кадр бегаем по всем элементам, если сектор нужно скомпилить, отправляем его на компиляцию.
Еще раз бегаем по всем элементам, если меш надо нарисовать - рисуем.

Если сектор скомпилировался, получаем нужный элемент в буфере с помощью функции get и изменяем меш.

Остается только заполнять этот буфер секторами.
На входе у нас события загрузки/выгрузки сектора, события добавления, удаления элементов данного буфера.

Событие загрузки / выгрузки сектора - с помощью функции get устанавливаем сектор или удаляем. А также заносим сектор в список, вероятно разреженную мапу.

Событие добавления элемента - ищем нужный элемент в мапе, если есть - добавляем.

Событие удаления - просто обнуляем элемент.

и сценарий - мы двигаемся по миру

Где то в середине кадра:
Позиция чанклоадера вокруг игрока изменится.
Позиция зоны рисования вокруг игрока изменится.

В конце этого кадра:
Выгрузятся нужные сектора. Запустится процесс загрузки новых секторов.
В буфере рисования удалятся (обнулятся) сектора и меши которые вышли за границу области рисования.
В списке загруженных секторов ищем новые сектора которые нужно рисовать и добавляем их в буфер рисования если они есть. (такие сектора найдутся в 2х случаях - они уже были загружены другим чанклоадером и есть в списке загрузки, они добавились в буфер загрузки только что - это сектора которые уже были загружены но валялись в кеше и не были в списке загрузки)

Если какой то сектор загрузился, формируется событие загрузки. Этот сектор добавляется в список загруженных секторов и в буфер рисования если он в области рисования.

При добавлении сектора в буфер рисования он отправляется на компиляцию. Не зависимо от того, нужно его скомпилировать или нет.

В середине кадра:
Бегаем по буферу рисования. Если сектор не был отправлен на компиляцию и его надо скомпилировать - отправляем на компиляцию.
Бегаем по буферу рисования. Если меш есть, рисуем его.

В конце кадра:
Если сектор скомпилировался, ищем его в буфере рисования и если нашли - обновляем меш.

если проследить путь от загрузки до рисования то будет так:
В середине кадра:
Запускаем загрузку сектора

В конце этого(возможно, если конец кадра наступит еще не скоро) или следующих кадров:
Сектор загрузился, добавляем его в буфер рисования, сразу же запускаем компиляцию.

В конце этого (очень маловероятно) или следующих кадров:
Сектор скомпилировался, обновляем меш в буфере рисования.

В середине след. кадра:
Рисуем меш.


Бегаем по элементам, если сектор нужно скомпилить и он не был добавлен, добавляем на компиляцию. added = false

Бегаем по элементам, если сектор присутствует рисуем меш.

Событие начала компиляции. Ищем сектор в массиве и загружаем компилятор данными, если нашли.
Если не нашли сектор, значит пока мы ждали сектор вышел за пределы. Ничего не делаем.
Если нашли сектор, но он отсутствует, значит сектор выгрузился. added = false
Событие завершении компиляции. Ищем сектор в массиве и обновляем меш, если нашли. added = false


Событие удаления элемента буфера. Удаляем сектор.
Событие добавления элемента буфера. Ищем в списке секторов сектор. Добавляем если находим. if (!added) Ставим сектор на компиляцию.

Событие добавления сектора. Ищем сектор в буфере. Добавляем если находим. if (!added) Ставим сектор на компиляцию.
Событие удаления сектора. Ищем сектор в буфере. Удаляем если находим.

Добавили сектор. Добавили на компиляцию. Удалили сектор. Добавили сектор. Добавили на компиляцию. Завершили компиляцию. Завершили компиляцию.

другой вариант:

Событие добавление сектора. UseSector(pos). Добавляем сектор. Если не поставлен на компиляцию, ставим на компиляцию. UseSector(pos).
Событие удаления сектора. Удаляем сектор. UnuseSector(pos).

Событие начала компиляции. Если сектор есть, загружаем компилятор данными. Если нету, UnuseSector(pos). return false.
Событие конца компиляции. Если сектор есть, обновляем меш. UnuseSector(pos).

Событие добавления элемента буфера. UseSector(pos). Добавляем элемент в буфер. Если не поставлен на компиляцию, ставим на компиляцию. UseSector(pos).
Событие удаления элемента буфера. UnuseSector(pos). 

Бегаем по элементам. Если не поставлен на компиляцию, ставим на компиляцию. UseSector(pos).
Бегаем по элементам, если сектор присутствует рисуем меш.

